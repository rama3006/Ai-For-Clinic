import { createClient } from "@supabase/supabase-js";
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const SUPABASE_URL   = process.env.SUPABASE_URL;
const SUPABASE_KEY   = process.env.SUPABASE_SERVICE_KEY;
const ADMIN_SECRET   = process.env.ADMIN_SECRET || "";
const EMBED_MODEL    = "text-embedding-3-small";
const sb = createClient(SUPABASE_URL, SUPABASE_KEY, { auth: { persistSession: false } });

function chunkText(str, max = 800) {
  const s = String(str || ""); const out = [];
  for (let i=0; i<s.length; i+=max) out.push(s.slice(i, i+max));
  return out;
}
async function embedBatch(texts) {
  const r = await fetch("https://api.openai.com/v1/embeddings", {
    method: "POST",
    headers: { "Authorization": `Bearer ${OPENAI_API_KEY}`, "Content-Type": "application/json" },
    body: JSON.stringify({ model: EMBED_MODEL, input: texts })
  });
  const j = await r.json();
  if (!r.ok) throw new Error(j.error?.message || "embed error");
  return j.data.map(d => d.embedding);
}

export default async function handler(req, res) {
  try {
    const { clinicId = "CLINIC_DEMO", secret = "" } = req.query || {};
    if (secret !== ADMIN_SECRET) return res.status(401).json({ ok:false, error:"unauthorized" });

    await sb.from("kb_chunks").delete().eq("clinic_id", clinicId);

    const [faqs, svcs] = await Promise.all([
      sb.from("faqs").select("id,question,answer,lang").eq("clinic_id", clinicId).eq("is_published", true),
      sb.from("services").select("id,service,details,lang").eq("clinic_id", clinicId).eq("is_published", true)
    ]);

    const rows = [];
    for (const f of (faqs.data || [])) {
      const merged = `Q: ${f.question}\nA: ${f.answer}`;
      chunkText(merged).forEach((p,i)=> rows.push({ clinic_id: clinicId, source_type:"faq", source_id:f.id, chunk_id:i+1, content:p, lang:f.lang||"en" }));
    }
    for (const s of (svcs.data || [])) {
      const merged = `${s.service}: ${s.details}`;
      chunkText(merged).forEach((p,i)=> rows.push({ clinic_id: clinicId, source_type:"service", source_id:s.id, chunk_id:i+1, content:p, lang:s.lang||"en" }));
    }

    for (let i=0; i<rows.length; i+=64) {
      const slice = rows.slice(i, i+64);
      const vecs = await embedBatch(slice.map(r => r.content));
      const toInsert = slice.map((r, idx) => ({ ...r, embedding: vecs[idx] }));
      await sb.from("kb_chunks").insert(toInsert);
    }
    return res.status(200).json({ ok:true, inserted: rows.length });
  } catch (e) {
    return res.status(500).json({ ok:false, error:String(e) });
  }
}
